Final Exam
				  ==============
Answer to the Question number 1 (a):
The big O performance of a search will be O(n) and not O(log2(n)) because in a sorted linked list, we must traverse each element one by one to find a value, even if the list is sorted. Unlike arrays, linked lists do not support direct (random) access to elements, so binary search (which requires jumping to the middle element) is not possible. This makes the search time linear for example, O(n), because we may have to look at every node in the worst case.
Answer to the Question number 1 (b):
To sort an array in a descending order, by creating a binary heap from the array (using heapify process) and then removing each element from the heap and then removing each element from the heap and putting it at the back of the array, we need a min-heap. When we remove the smallest element (which is at the root of a min-heap) and place it at the end of the array repeatedly, the result will be sorted in descending order. If we used a max-heap, the largest element would be removed first, giving the ascending order instead.
Answer to the Question number 1 (c):
Here I have sorted the performance function from slowest to fastest:
1.	O(n²) – Example: Bubble Sort
2.	O(n√n) – Example: Some optimized sorts
3.	O(n log₂(n)) – Example: Merge Sort, Heap Sort
4.	O(√n) – Example: Jump Search
5.	O(log₃(n)) – Logarithmic
6.	O(log₂(n)) – Logarithmic
Answer to the Question number 2:
Here I have solved this step by step:
T(n) = 2 + 2T(n/4)
→ T(n) = 2 + 2[2 + 2T(n/16)]
→ T(n) = 2 + 4 + 4T(n/16)
→ T(n) = 2 + 4 + 8 + 8T(n/64)
...
At level k: T(n) = 2 + 4 + 8 + ... + 2^k + 2^k * T(n/4^k)
Stop when n/4^k = 1 → 4^k = n → k = log₄(n)
Sum of series: 2 + 4 + 8 + ... + 2^k = 2^(k+1) - 2
→ So final: T(n) = 2^(log₄(n)+1) - 2
  = 2 * n^½ - 2 = O(√n)
So: T(n) = 2√n – 2
        O(f(n)) = O(√n)
Answer to the Question number 3 (a):
Here are the heights of the complete Binary trees -
1.	Complete Binary Tree with 7 Nodes, Height = 2.
2.	Complete Binary Tree with 16 Nodes, Height = 4
Answer to the Question number 3 (b):
The depth of the last node in each of the above trees are -
1.	Depth of last node = 2
2.	Depth of last node = 4
Answer to the Question number 3 (c):
Here is the list of the node values in a post-order, and a breath-first manners -
1.	Post-order Traversal: 1, 4, 3, 6, 8, 7, 5, 11, 13, 12, 16, 20, 18, 15, 10
2.	Breadth-first Traversal: 10, 5, 15, 3, 7, 12, 18, 1, 4, 6, 8, 11, 13, 16, 20
 
Answer to the Question number 4:
Here I have Created a max heap (larger the value, higher the priority) by inserting these values in order - 8 9 12 4 5 7 11 4 10 and removed two numbers from the heap, identify the removed numbers and draw the heap after each removal –
 


Answer to the Question number 5 (a):
Here I have built the Adjacency Matrix -
This is a square matrix where:
1.	Rows and columns represent nodes
2.	A cell (i, j) contains the cost/weight if there’s an edge from node i to j; otherwise 0 or ∞
Edges with weights:
0 → 2 (5), 0 → 3 (2)
1 → 0 (1), 1 → 4 (2)
2 → 1 (3)
3 → 2 (1)
4 → 3 (6)
Adjacency Matrix (5x5):
    0   1   2   3   4
0 [ 0,  0,  5,  2,  0 ]
1 [ 1,  0,  0,  0,  2 ]
2 [ 0,  3,  0,  0,  0 ]
3 [ 0,  0,  1,  0,  0 ]
4 [ 0,  0,  0,  6,  0 ]
Answer to the Question number 5 (b):
Here I have built the Adjacency List -
List all outgoing edges from each node:
0 → [(2, 5), (3, 2)]
1 → [(0, 1), (4, 2)]
2 → [(1, 3)]
3 → [(2, 1)]
4 → [(3, 6)]
Answer to the Question number 5 (c):
Yes, there are two paths from 0 to 1. Here are the the cost(s) of the path(s)?
Path A: 0 → 2 → 1 → Cost = 5 + 3 = 8
Path B: 0 → 3 → 2 → 1 → Cost = 2 + 1 + 3 = 6
Shortest path from 0 to 1 is 6.
Answer to the Question number 5 (d):
Yes, there is a cycle in the graph. Here I have identified the cycle -
1 → 0 → 3 → 2 → 1, This forms a cycle of length 4.
Answer to the Question number 5 (e):
The shortest path from 1 to 0 is -
Direct edge: 1 → 0 with weight 1 So, shortest path = 1
Answer to the Question number 6:
Inserted BST values - 5, 3, 6, 2, 8, 4, 9, 7, 11
Initial BST structure:
 
Balance factor analysis: Balance = height (left subtree) - height (right subtree)
Node 11: balance = 0 (leaf node)
Node 9: balance = -1 (right-heavy due to 11)
Node 8: balance = -1 (right heavy)
Node 6: balance = -3 → indicates Right-Right (RR) imbalance
Node 5: balance = -2 (due to deep right subtree), recheck after fixing node 6
Nodes that need rotation:
1. A Left Rotation at node 6 to fix the RR imbalance.
2. After rotation, check balance at node 5 again. If still unbalanced, apply another rotation. The diagram below shows the original BST structure, the balance issues, and the rotation needed.
