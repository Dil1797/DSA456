                          Part A - Recursive functions
                    ============================
Function 1: Factorial
def factorial(number):
    if number == 0 or number == 1:  # Base case: 0! = 1, 1! = 1
        return 1
    return number * factorial(number - 1)  # Recursive case
Example:
print(factorial(5))  # Output: 120
Explanation: The base case ensures that when number reaches 0 or 1, it stops recursing. Otherwise, it multiplies number by the factorial of number - 1, reducing the problem size at each step.

Function 2: Linear Search
def linear_search(lst, key, index=0):
    if index >= len(lst):  # Base case: key not found
        return -1
    if lst[index] == key:  # Found the key, return index
        return index
    return linear_search(lst, key, index + 1)  # Recursive case: check next index
Example:
numbers = [10, 20, 30, 40, 50]
print(linear_search(numbers, 30))  # Output: 2
print(linear_search(numbers, 60))  # Output: -1
Explanation: The base case occurs when the index reaches the end of the list (index >= len(lst)) → return -1. If the current element (lst[index]) matches the key, return the index. Otherwise, move to the next index (index + 1) and search again.
Function 3: Binary Search
def binary_search(lst, key, left=0, right=None):
    if right is None:
        right = len(lst) - 1  # Set right boundary initially
    
    if left > right:  # Base case: key not found
        return -1

    mid = (left + right) // 2  # Find middle index
    
    if lst[mid] == key:  # Key found
        return mid
    elif key < lst[mid]:  # Search in the left half
        return binary_search(lst, key, left, mid - 1)
    else:  # Search in the right half
        return binary_search(lst, key, mid + 1, right)
Example:
sorted_numbers = [10, 20, 30, 40, 50]
print(binary_search(sorted_numbers, 30))  # Output: 2
print(binary_search(sorted_numbers, 60))  # Output: -1
Explanation: The base case occurs when the search range is invalid (left > right) → return -1. Find the midpoint (mid).
If key == lst[mid], return mid.
If key is smaller, search left half (left, mid - 1).
If key is larger, search right half (mid + 1, right).
Only works on a sorted list!

Function 4: Tower of Hanoi
def tower_of_hanoi(n, source, target, auxiliary):
    if n == 1:  # Base case: Move 1 disk directly
        print(f"{source} to {target}")
        return
    # Move n-1 disks from source to auxiliary using target
    tower_of_hanoi(n - 1, source, auxiliary, target)
    # Move the nth disk from source to target
    print(f"{source} to {target}")
    # Move n-1 disks from auxiliary to target using source
    tower_of_hanoi(n - 1, auxiliary, target, source)
Example: 
Move 3 disks from Tower 1 to Tower 3 using Tower 2
tower_of_hanoi(3, 1, 3, 2)
Explanation:
Base case: If there is only 1 disk, move it directly to the target.
Recursive case:
Move n-1 disks from source to auxiliary using target.
Move the nth (largest) disk to the target.
Move n-1 disks from auxiliary to target using source.
Example output for 3 disks:
1 to 3
1 to 2
3 to 2
1 to 3
2 to 1
2 to 3
1 to 3

                               Part B – Analysis
                         ===================

Function 1:
def function1(value, number):
    if (number == 0):
        return 1
    elif (number == 1):
        return value
    else:
        return value * function1(value, number-1)
Step 1: Define T(n)
T(n) represents the number of operations for function1(value, number).
The base cases (number == 0 or number == 1) take constant time O(1).
The recursive case does:
One multiplication (value * function1(value, number - 1))
One recursive call to function1(value, number - 1), which takes T(n-1) operations.
Thus, the recurrence relation is:
T(n)=T(n−1)+1
Step 2: Expand the Recurrence
Expanding it step by step:
T(n)=T(n−1)+1
T(n−1)=T(n−2)+1
T(n−2)=T(n−3)+1
...
T(1)=1
After n expansions, we get:
T(n)=T(1)+(n−1)⋅1
T(n)=1+(n−1)
T(n)=O(n)
Conclusion:
The function performs O(n) (linear time) operations because it calls itself n times before reaching the base case.

Function 2:
def recursive_function2(mystring, a, b):
    if(a >= b):
        return True
    else:
        if(mystring[a] != mystring[b]):
            return False
        else:
            return recursive_function2(mystring, a+1, b-1)

def function2(mystring):
    return recursive_function2(mystring, 0, len(mystring)-1)
Step 1: Define T(n)
function2(mystring) calls recursive_function2(mystring, 0, len(mystring) - 1), so we analyze recursive_function2.
The base case (a >= b) runs in O(1).
The recursive case:
One comparison (mystring[a] != mystring[b]).
One recursive call with a+1, b-1, reducing the problem size by 2.
Thus, the recurrence relation is:
T(n)=T(n−2)+2
Step 2: Expand the Recurrence
Expanding:
T(n)=T(n−2)+2
T(n−2)=T(n−4)+2
T(n−4)=T(n−6)+2
...
T(2)=O(1)
After approximately n/2 steps:
T(n)=O(n/2)
Conclusion:
Since O(n/2) simplifies to O(n), this function runs in O(n) linear time.

Function 3: Solve T(n) = T(n/2) + 3
Step 1: Expand the Recurrence
Expanding recursively:

T(n)=T(n/2)+3
T(n/2)=T(n/4)+3
T(n/4)=T(n/8)+3
... At the k-th step, n reduces to n/2^k:
T(n)=T(n/2 k)+3k
Step 2: Find k where n/2^k = 1
Solving:
n/2^k = 1
k=log 2n
At k = log(n), we reach T(1) = O(1), so:
T(n)=O(3logn)
Conclusion:
Ignoring constants, the function is O(log n) logarithmic time.

Function 4:
def function3(value, number):
    if (number == 0):
        return 1
    elif (number == 1):
        return value
    else:
        half = number // 2
        result = function3(value, half)
        if (number % 2 == 0):
            return result * result
        else:
            return value * result * result
Step 1: Define T(n)
The base cases (number == 0 or number == 1) run in O(1).
The recursive case:
Calls function3(value, number // 2), reducing the problem size by half.
Performs O(1) multiplications.
Thus, the recurrence relation is:
T(n)=T(n/2)+O(1)
Step 2: Expand the Recurrence
T(n)=T(n/2)+1
T(n/2)=T(n/4)+1
T(n/4)=T(n/8)+1
... At step k, n reduces to 1:
n/2^k =1
Solving for k:
k=log 2 n
Thus:
T(n)=O(logn)
Conclusion:
This function runs in O(log n) logarithmic time, similar to fast exponentiation (exponentiation by squaring).
